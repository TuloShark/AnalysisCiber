enough.c: (in function cleanup)
enough.c:188:17: Test expression for if not boolean, type size_t: done[n].len
  Test expression type is not boolean or int. (Use -predboolint to inhibit
  warning)
enough.c:190:14: Only storage done->vec (type char *) derived from released
                    storage is not released (memory leak): done
  A storage leak due to incomplete deallocation of a structure or deep pointer
  is suspected. Unshared storage that is reachable from a reference that is
  being deallocated has not yet been deallocated. Splint assumes when an object
  is passed as an out only void pointer that the outer object will be
  deallocated, but the inner objects will not. (Use -compdestroy to inhibit
  warning)
enough.c:190:14: Unqualified static storage done passed as only param:
                    free (done)
  Static storage is transferred in an inconsistent way. (Use -statictrans to
  inhibit warning)
enough.c:193:14: Unqualified static storage num passed as only param:
                    free (num)
enough.c:195:14: Unqualified static storage code passed as only param:
                    free (code)
enough.c:196:2: Function returns with global done referencing released storage
  A global variable does not satisfy its annotations when control is
  transferred. (Use -globstate to inhibit warning)
   enough.c:190:14: Storage done released
enough.c:196:2: Function returns with non-null global done referencing null
                   storage
enough.c:196:2: Function returns with global num referencing released storage
   enough.c:193:14: Storage num released
enough.c:196:2: Function returns with non-null global num referencing null
                   storage
enough.c:196:2: Function returns with global code referencing released storage
   enough.c:195:14: Storage code released
enough.c:196:2: Function returns with non-null global code referencing null
                   storage
enough.c: (in function count)
enough.c:220:24: Left operand of >> may be negative (int): (syms - 1) >> 1
  The left operand to a shift operator may be negative (behavior is
  implementation-defined). (Use -shiftimplementation to inhibit warning)
enough.c:220:38: Left operand of >> may be negative (int): (syms - 2) >> 1
enough.c:220:53: Left operand of >> may be negative (int): left >> 1
enough.c:222:9: Test expression for if not boolean, type big_t: got
enough.c:227:14: Left operand of << may be negative (int): left << 1
enough.c:234:30: Right operand of << may be negative (int):
                    (code_t)left << (max - len)
  The right operand to a shift operator may be negative (behavior undefined).
  (Use -shiftnegative to inhibit warning)
enough.c:235:28: Right operand of << may be negative (int):
                    (code_t)1 << (max - len)
enough.c:234:5: Assignment of unsigned long long to int:
                   most = (((code_t)left << (max - len)) - syms) / (((code_t)1
                   << (max - len)) - 1)
  To ignore signs in type comparisons use +ignoresigns
enough.c:240:42: Left operand of << may be negative (int): (left - use) << 1
enough.c:242:13: Operands of == have incompatible types (big_t, int):
                    got == (big_t)0 - 1
  Types are incompatible. (Use -type to inhibit warning)
enough.c: (in function beenhere)
enough.c:267:24: Left operand of >> may be negative (int): (syms - 1) >> 1
enough.c:267:38: Left operand of >> may be negative (int): (syms - 2) >> 1
enough.c:267:53: Left operand of >> may be negative (int): left >> 1
enough.c:268:17: Right operand of << may be negative (int): 1 << root
enough.c:269:15: Left operand of >> may be negative (int): mem >> 3
enough.c:269:5: Assignment of int to size_t: offset = (mem >> 3) + rem
  To allow arbitrary integral types to match any integral type, use
  +matchanyintegral.
enough.c:271:16: Right operand of << may be negative (int): 1 << (mem & 7)
enough.c:275:28: Operands of != have incompatible types (char, int):
                    (done[index].vec[offset] & bit) != 0
enough.c:283:13: Test expression for if not boolean, type size_t: length
enough.c:294:27: Right operand of << may be negative (int): 1 << (len - root)
enough.c:294:13: Assignment of int to size_t: length = 1 << (len - root)
enough.c:298:9: Clauses exit with vector referencing local storage in true
                   branch, fresh storage in false branch
  The state of a variable is different depending on which branch is taken. This
  means no annotation can sensibly be applied to the storage. (Use -branchstate
  to inhibit warning)
   enough.c:297:13: Fresh storage vector created
enough.c:302:13: Return value (type int) ignored: fputs("abort: un...
  Result returned by function call is not used. If this is intended, can cast
  result to (void) to eliminate message. (Use -retvalint to inhibit warning)
enough.c:304:18: Argument to exit has implementation defined behavior: 1
  The argument to exit should be 0, EXIT_SUCCESS or EXIT_FAILURE (Use -exitarg
  to inhibit warning)
enough.c: (in function examine)
enough.c:336:24: Right operand of << may be negative (int): 1 << (len - root)
enough.c:346:21: Test expression for if not boolean, type int: code[use]
enough.c:348:21: Return value (type int) ignored: putchar('\n')
enough.c:349:13: Return value (type int) ignored: fflush(stdout)
enough.c:358:9: Test expression for if not boolean, type int:
                   beenhere(syms, len, left, mem, rem)
enough.c:363:14: Left operand of << may be negative (int): left << 1
enough.c:370:30: Right operand of << may be negative (int):
                    (code_t)left << (max - len)
enough.c:371:28: Right operand of << may be negative (int):
                    (code_t)1 << (max - len)
enough.c:370:5: Assignment of unsigned long long to int:
                   most = (((code_t)left << (max - len)) - syms) / (((code_t)1
                   << (max - len)) - 1)
enough.c:377:20: Right operand of << may be negative (int): 1 << (len - root)
enough.c:385:38: Left operand of << may be negative (int): (left - use) << 1
enough.c:386:35: Right operand of << may be negative (int): 1 << (len - root)
enough.c:386:24: Test expression for conditional not boolean, type int: rem
enough.c:386:54: Left operand of << may be negative (int): rem << 1
enough.c:388:24: Right operand of << may be negative (int): 1 << (len - root)
enough.c: (in function enough)
enough.c:414:18: Right operand of << may be negative (int): 1 << root
enough.c:421:36: Left operand of >> may be negative (int): (n - 1) >> 1
enough.c:421:47: Left operand of >> may be negative (int): (n - 2) >> 1
enough.c:421:59: Left operand of >> may be negative (int): left >> 1
enough.c:422:39: Right operand of && is non-boolean (big_t):
                    root + 1 < max && num[index]
  The operand of a boolean operator is not a boolean. Use +ptrnegate to allow !
  to be used on pointers. (Use -boolops to inhibit warning)
enough.c:423:53: Right operand of << may be negative (int): 1 << root
enough.c:427:44: Left operand of << may be negative (int): left << 1
enough.c:427:21: Left operand of && is non-boolean (big_t):
                    num[index - 1] && n <= left << 1
enough.c:428:29: Left operand of << may be negative (int): (n - left) << 1
enough.c:428:56: Left operand of << may be negative (int): (n - left) << 1
enough.c:429:34: Right operand of << may be negative (int): 1 << root
enough.c: (in function main)
enough.c:484:9: Return value (type int) ignored: fputs("invalid a...
enough.c:486:18: Function returns with non-null global code referencing null
                    storage
   enough.c:467:12: Storage code becomes null
enough.c:486:18: Function returns with non-null global num referencing null
                    storage
   enough.c:468:11: Storage num becomes null
enough.c:486:18: Function returns with non-null global done referencing null
                    storage
   enough.c:469:12: Storage done becomes null
enough.c:494:27: Test expression for for not boolean, type code_t: word
enough.c:498:62: Right operand of >> may be negative (int):
                    ((code_t)0 - 1) >> (max - 1)
enough.c:498:43: Left operand of >> may be negative (int):
                    ((code_t)0 - 1) >> (max - 1)
enough.c:498:20: Operands of >= have incompatible types (code_t, int):
                    (code_t)(syms - 2) >= (((code_t)0 - 1) >> (max - 1))
enough.c:499:9: Return value (type int) ignored: fputs("abort: co...
enough.c:500:18: Function returns with non-null global code referencing null
                    storage
   enough.c:467:12: Storage code becomes null
enough.c:500:18: Function returns with non-null global num referencing null
                    storage
   enough.c:468:11: Storage num becomes null
enough.c:500:18: Function returns with non-null global done referencing null
                    storage
   enough.c:469:12: Storage done becomes null
enough.c:504:44: Right operand of << may be negative (int): (code_t)1 << max
enough.c:507:18: Function returns with non-null global code referencing null
                    storage
   enough.c:467:12: Storage code becomes null
enough.c:507:18: Function returns with non-null global num referencing null
                    storage
   enough.c:468:11: Storage num becomes null
enough.c:507:18: Function returns with non-null global done referencing null
                    storage
   enough.c:469:12: Storage done becomes null
enough.c:511:19: Function calloc expects arg 1 to be size_t gets int: max + 1
enough.c:511:5: Only storage assigned to unqualified static:
                   code = calloc(max + 1, sizeof(int))
  The only reference to this storage is transferred to another reference (e.g.,
  by returning it) that does not have the only annotation. This may lead to a
  memory leak, since the new reference is not necessarily released. (Use
  -onlytrans to inhibit warning)
enough.c:513:9: Return value (type int) ignored: fputs("abort: un...
enough.c:514:18: Function returns with non-null global code referencing null
                    storage
   enough.c:511:12: Storage code may become null
enough.c:514:18: Function returns with non-null global num referencing null
                    storage
   enough.c:468:11: Storage num becomes null
enough.c:514:18: Function returns with non-null global done referencing null
                    storage
   enough.c:469:12: Storage done becomes null
enough.c:522:16: Left operand of >> may be negative (int): syms >> 1
enough.c:522:9: Assignment of int to size_t: size = syms >> 1
enough.c:523:43: Left operand of >> may be negative (int): (syms - 1) >> 1
enough.c:523:13: Operands of > have incompatible types (size_t, int):
                    size > ((size_t)0 - 1) / (n = (syms - 1) >> 1)
enough.c:524:29: Operands of > have incompatible types (size_t, int):
                    size > ((size_t)0 - 1) / (n = max - 1)
enough.c:526:18: Only storage assigned to unqualified static:
                    num = calloc(size, sizeof(big_t))
enough.c:527:13: Return value (type int) ignored: fputs("abort: un...
enough.c:529:22: Function returns with non-null global num referencing null
                    storage
   enough.c:468:11: Storage num may become null
enough.c:529:22: Function returns with non-null global done referencing null
                    storage
   enough.c:469:12: Storage done becomes null
enough.c:538:13: Operands of == have incompatible types (big_t, int):
                    got == (big_t)0 - 1
enough.c:539:13: Return value (type int) ignored: fputs("abort: ca...
enough.c:541:22: Function returns with non-null global num referencing null
                    storage
   enough.c:520:15: Storage num may become null
enough.c:541:22: Function returns with non-null global done referencing null
                    storage
   enough.c:469:12: Storage done becomes null
enough.c:549:9: Return value (type int) ignored: puts(" (no lengt...
enough.c:555:15: Only storage assigned to unqualified static:
                    done = calloc(size, sizeof(struct tab))
enough.c:556:9: Return value (type int) ignored: fputs("abort: un...
enough.c:558:18: Function returns with non-null global num referencing null
                    storage
   enough.c:520:15: Storage num may become null
enough.c:558:18: Function returns with non-null global done referencing null
                    storage
   enough.c:469:12: Storage done may become null
enough.c:564:38: Right operand of << may be negative (int):
                    (code_t)1 << (root + 1)
enough.c:567:9: Return value (type int) ignored: puts("cannot han...
enough.c:571:14: Function returns with non-null global num referencing null
                    storage
   enough.c:520:15: Storage num may become null
enough.c:571:14: Function returns with non-null global done referencing null
                    storage
   enough.c:553:16: Storage done may become null
gzappend.c: (in function bye)
gzappend.c:96:10: Argument to exit has implementation defined behavior: 1
gzappend.c: (in function gcd)
gzappend.c:106:12: Operands of && are non-boolean (unsigned int): a && b
gzappend.c: (in function rotate)
gzappend.c:140:32: Function memcpy expects arg 3 to be size_t gets unsigned
                      int: len - 1
gzappend.c:140:16: Parameter 1 (list) to function memcpy is declared unique but
                      is aliased by parameter 2 (list + 1)
  A unique or only parameter is aliased by some other parameter or visible
  global. (Use -aliasunique to inhibit warning)
gzappend.c:148:33: Function memmove expects arg 3 to be size_t gets unsigned
                      int: len - 1
gzappend.c:165:10: Variable to used before definition
  An rvalue is used that may not be initialized to a value on some execution
  path. (Use -usedef to inhibit warning)
gzappend.c:166:14: Test expression for while not boolean, type unsigned int:
                      --cycles
gzappend.c: (in function readin)
gzappend.c:184:38: Right operand of << may be negative (int): 1 << in->size
gzappend.c:184:33: Function read expects arg 3 to be size_t gets int:
                      1 << in->size
gzappend.c:184:5: Assignment of ssize_t to int:
                     len = read(in->fd, in->buf, 1 << in->size)
gzappend.c:187:5: Implicitly only storage in->next (type unsigned char *) not
                     released before assignment: in->next = in->buf
  A memory leak has been detected. Only-qualified storage is not released
  before the last reference to it is lost. (Use -mustfreeonly to inhibit
  warning)
gzappend.c:188:16: Storage in->buf reachable from parameter is kept (should be
                      implicitly only)
  Storage derivable from a parameter does not match the alias kind expected for
  the formal parameter. (Use -compmempass to inhibit warning)
   gzappend.c:187:5: Storage in->buf becomes kept
gzappend.c: (in function skip)
gzappend.c:208:31: Right operand of << may be negative (int): 1U << in->size
gzappend.c:209:13: Test expression for if not boolean, type unsigned int:
                      bypass
gzappend.c:210:31: Function lseek expects arg 2 to be __off_t gets off_t:
                      (off_t)bypass
  To allow arbitrary integral types to match long unsigned, use +longintegral.
gzappend.c:214:9: Return value (type int) ignored: readmore(in)
gzappend.c: (in function read4)
gzappend.c:227:5: Assignment of unsigned char to unsigned long int:
    val = (in->left == 0 ? readmore(in) : 0, in->left--, *(in->next)++)
  To make char and int types equivalent, use +charint.
gzappend.c: (in function gzheader)
gzappend.c:240:9: Operands of != have incompatible types (unsigned char, int):
    (in->left == 0 ? readmore(in) : 0, in->left--, *(in->next)++) != 31
gzappend.c:240:99: Operands of != have incompatible types (unsigned char, int):
    (in->left == 0 ? readmore(in) : 0, in->left--, *(in->next)++) != 139
gzappend.c:241:9: Operands of != have incompatible types (unsigned char, int):
    (in->left == 0 ? readmore(in) : 0, in->left--, *(in->next)++) != 8
gzappend.c:242:5: Assignment of unsigned char to int:
    flags = (in->left == 0 ? readmore(in) : 0, in->left--, *(in->next)++)
gzappend.c:243:9: Test expression for if not boolean, type int: flags & 0xe0
gzappend.c:245:9: Test expression for if not boolean, type int: flags & 4
gzappend.c:246:9: Assignment of unsigned char to unsigned int:
    n = (in->left == 0 ? readmore(in) : 0, in->left--, *(in->next)++)
gzappend.c:250:9: Test expression for if not boolean, type int: flags & 8
gzappend.c:250:27: Operands of != have incompatible types (unsigned char, int):
    (in->left == 0 ? readmore(in) : 0, in->left--, *(in->next)++) != 0
gzappend.c:251:9: Test expression for if not boolean, type int: flags & 16
gzappend.c:251:28: Operands of != have incompatible types (unsigned char, int):
    (in->left == 0 ? readmore(in) : 0, in->left--, *(in->next)++) != 0
gzappend.c:252:9: Test expression for if not boolean, type int: flags & 2
gzappend.c: (in function gzscan)
gzappend.c:270:32: Null storage passed as non-null param: open (..., 0)
  A possibly null pointer is passed as a parameter corresponding to a formal
  parameter with no /*@null@*/ annotation.  If NULL may be used for this
  parameter, add a /*@null@*/ annotation to the function parameter declaration.
  (Use -nullpass to inhibit warning)
gzappend.c:272:21: Function malloc expects arg 1 to be size_t gets unsigned
                      int: (1U << 14)
gzappend.c:278:14: Possibly null storage gz.buf derivable from parameter
                      gzheader (&gz)
  A possibly null pointer is reachable from a parameter or global variable that
  is not declared using a /*@null@*/ annotation. (Use -nullstate to inhibit
  warning)
   gzappend.c:272:14: Storage gz.buf may become null
gzappend.c:278:14: Passed storage gz contains 2 undefined fields: buf, next
  Storage derivable from a parameter, return value or global is not defined.
  Use /*@out@*/ to denote passed or returned storage which need not be defined.
  (Use -compdef to inhibit warning)
gzappend.c:281:21: Function malloc expects arg 1 to be size_t gets unsigned
                      int: 32768U
gzappend.c:283:5: Assignment of int to alloc_func: strm->zalloc = 0
gzappend.c:283:5: Implicitly only storage strm->zalloc (type alloc_func) not
                     released before assignment: strm->zalloc = 0
gzappend.c:284:5: Assignment of int to free_func: strm->zfree = 0
gzappend.c:284:5: Implicitly only storage strm->zfree (type free_func) not
                     released before assignment: strm->zfree = 0
gzappend.c:285:5: Implicitly only storage strm->opaque (type voidpf) not
                     released before assignment: strm->opaque = 0
gzappend.c:286:25: Null storage strm->zalloc derivable from parameter
                      inflateInit2_ ((strm), ...)
   gzappend.c:283:20: Storage strm->zalloc becomes null
gzappend.c:286:25: Null storage strm->zfree derivable from parameter
                      inflateInit2_ ((strm), ...)
   gzappend.c:284:19: Storage strm->zfree becomes null
gzappend.c:286:25: Null storage strm->opaque derivable from parameter
                      inflateInit2_ ((strm), ...)
   gzappend.c:285:20: Storage strm->opaque becomes null
gzappend.c:291:5: Assignment of long int to off_t:
                     lastoff = lseek(gz.fd, 0L, SEEK_CUR) - gz.left
gzappend.c:294:5: Implicitly only storage strm->next_in (type Bytef *) not
                     released before assignment: strm->next_in = gz.next
gzappend.c:295:21: Null storage passed as non-null param: crc32 (..., 0, ...)
gzappend.c:296:5: Assignment of int to unsigned int: have = full = 0
gzappend.c:300:22: Storage gz.next reachable from passed parameter is kept
                      (should be implicitly only): &gz
   gzappend.c:294:5: Storage gz.next becomes kept
gzappend.c:300:13: Return value (type int) ignored: readmore(&gz)
gzappend.c:302:13: Implicitly only storage strm->next_in (type Bytef *) not
                      released before assignment: strm->next_in = gz.next
gzappend.c:302:13: Kept storage gz.next assigned to implicitly only:
                      strm->next_in = gz.next
  storage is transferred to a non-temporary reference after being passed as
  keep parameter. The storage may be released or new aliases created. (Use
  -kepttrans to inhibit warning)
   gzappend.c:294:5: Storage gz.next becomes kept
gzappend.c:303:9: Clauses exit with strm->next_in referencing kept storage in
                     true branch, implicitly only storage in continuation
   gzappend.c:302:13: Storage strm->next_in becomes kept
gzappend.c:307:9: Implicitly only storage strm->next_out (type Bytef *) not
                     released before assignment: strm->next_out = window + have
gzappend.c:307:9: Dependent storage window assigned to implicitly only:
                     strm->next_out = window + have
  Dependent storage is transferred to a non-dependent reference. (Use
  -dependenttrans to inhibit warning)
   gzappend.c:307:26: Storage window becomes dependent
gzappend.c:310:23: Storage strm->next_in reachable from passed parameter is
                      unqualified (should be implicitly only): strm
gzappend.c:310:23: Passed storage *strm contains 1 undefined field: next_out
gzappend.c:317:26: Passed storage window not completely defined (*window is
                      undefined): crc32 (..., window + have, ...)
   gzappend.c:281:5: Storage *window allocated
gzappend.c:318:13: Test expression for if not boolean, type uInt:
                      strm->avail_out
gzappend.c:326:13: Test expression for if not boolean, type int:
                      strm->data_type & 128
gzappend.c:327:17: Test expression for if not boolean, type int:
                      strm->data_type & 64
gzappend.c:331:17: Assignment of long int to off_t:
                      lastoff = lseek(gz.fd, 0L, SEEK_CUR) - strm->avail_in
gzappend.c:335:5: Return value (type int) ignored: inflateEnd(strm)
gzappend.c:340:5: Assignment of long int to off_t:
                     end = lseek(gz.fd, 0L, SEEK_CUR) - gz.left
gzappend.c:350:9: Operands of || are non-booleans (unsigned int, int):
                     gz.left || readin(&gz)
gzappend.c:355:18: Incompatible types for - (off_t, boolean):
                      lastoff - (lastbit != 0)
  To make bool and int types equivalent, use +boolint.
gzappend.c:355:5: Return value (type __off_t) ignored: lseek(gz.fd, las...
  Result returned by function call is not used. If this is intended, can cast
  result to (void) to eliminate message. (Use -retvalother to inhibit warning)
gzappend.c:357:47: Right operand of << may be negative (int):
                      1 << ((8 - lastbit) & 7)
gzappend.c:358:5: Return value (type __off_t) ignored: lseek(gz.fd, -1L...
gzappend.c:362:9: Test expression for if not boolean, type int: full
gzappend.c:363:16: Possibly null storage window passed as non-null param:
                      rotate (window, ...)
   gzappend.c:281:14: Storage window may become null
gzappend.c:363:16: Passed storage window not completely defined (*window is
                      undefined): rotate (window, ...)
   gzappend.c:281:5: Storage *window allocated
gzappend.c:368:25: Storage strm->next_in reachable from passed parameter is
                      kept (should be implicitly only): (strm)
   gzappend.c:337:5: Storage strm->next_in becomes kept
gzappend.c:370:26: Storage strm->next_in reachable from passed parameter is
                      kept (should be implicitly only): strm
   gzappend.c:337:5: Storage strm->next_in becomes kept
gzappend.c:370:32: Possibly null storage window passed as non-null param:
                      deflateSetDictionary (..., window, ...)
   gzappend.c:281:14: Storage window may become null
gzappend.c:370:32: Passed storage window not completely defined (*window is
                      undefined): deflateSetDictionary (..., window, ...)
   gzappend.c:281:5: Storage *window allocated
gzappend.c:370:5: Return value (type int) ignored: deflateSetDictio...
gzappend.c:373:9: Test expression for if not boolean, type int: left
gzappend.c:374:22: Function lseek expects arg 2 to be __off_t gets off_t: --end
gzappend.c:374:9: Return value (type __off_t) ignored: lseek(gz.fd, --e...
gzappend.c:376:38: Function deflatePrime expects arg 3 to be int gets unsigned
                      char: *gz.buf
gzappend.c:376:22: Storage strm->next_in reachable from passed parameter is
                      kept (should be implicitly only): strm
   gzappend.c:337:5: Storage strm->next_in becomes kept
gzappend.c:376:9: Return value (type int) ignored: deflatePrime(str...
gzappend.c:378:18: Function lseek expects arg 2 to be __off_t gets off_t: end
gzappend.c:378:5: Return value (type __off_t) ignored: lseek(gz.fd, end...
gzappend.c:383:18: Only storage gz.next (type unsigned char *) derived from
    variable declared in this scope is not released (memory leak)
gzappend.c:383:18: Only storage gz.name (type char *) derived from variable
                      declared in this scope is not released (memory leak)
gzappend.c:383:18: Function returns with null storage derivable from parameter
                      strm->zalloc
   gzappend.c:283:20: Storage strm->zalloc becomes null
gzappend.c:383:18: Function returns with null storage derivable from parameter
                      strm->zfree
   gzappend.c:284:19: Storage strm->zfree becomes null
gzappend.c:383:18: Function returns with null storage derivable from parameter
                      strm->opaque
   gzappend.c:285:20: Storage strm->opaque becomes null
gzappend.c:383:18: Storage strm->next_in reachable from parameter is kept
                      (should be implicitly only)
   gzappend.c:337:5: Storage strm->next_in becomes kept
gzappend.c:383:18: Storage *strm reachable from parameter contains 1 undefined
                      field: next_out
gzappend.c: (in function gztack)
gzappend.c:397:35: Null storage passed as non-null param: open (..., 0)
gzappend.c:404:17: Function malloc expects arg 1 to be size_t gets unsigned
                      int: (1U << 14)
gzappend.c:405:18: Function malloc expects arg 1 to be size_t gets unsigned
                      int: (1U << 14)
gzappend.c:411:28: Function read expects arg 3 to be size_t gets unsigned int:
                      (1U << 14)
gzappend.c:411:24: Possibly null storage in passed as non-null param:
                      read (..., in, ...)
   gzappend.c:404:10: Storage in may become null
gzappend.c:411:9: Assignment of ssize_t to int: len = read(fd, in, (1U << 14))
gzappend.c:415:21: Possibly null storage name passed as non-null param:
                      fprintf (..., name, ...)
gzappend.c:419:9: Implicitly only storage strm->next_in (type Bytef *) not
                     released before assignment: strm->next_in = in
gzappend.c:420:13: Test expression for if not boolean, type int: len
gzappend.c:425:13: Implicitly only storage strm->next_out (type Bytef *) not
                      released before assignment: strm->next_out = out
gzappend.c:426:33: Left operand of && is non-boolean (int): last && len == 0
gzappend.c:426:27: Possibly null storage strm->next_out derivable from
                      parameter deflate (strm, ...)
   gzappend.c:425:30: Storage strm->next_out may become null
gzappend.c:426:27: Passed storage *strm contains 1 undefined field: next_out
gzappend.c:428:20: Test expression for while not boolean, type unsigned int:
                      left
gzappend.c:429:76: Function write expects arg 3 to be size_t gets unsigned int:
                      left
gzappend.c:429:33: Passed storage out not completely defined (*out is
    undefined): write (..., out + (1U << 14) - strm->avail_out - left, ...)
   gzappend.c:405:5: Storage *out allocated
gzappend.c:429:17: Assignment of ssize_t to int:
    len = write(gd, out + (1U << 14) - strm->avail_out - left, left)
gzappend.c:437:9: Test expression for if not boolean, type int: last
gzappend.c:438:9: Return value (type int) ignored: deflateEnd(strm)
gzappend.c:439:9: Index of possibly null pointer out: out
  A possibly null pointer is dereferenced.  Value is either the result of a
  function which may return null (in which case, code should check it is not
  null), or a global, parameter or structure field declared with the null
  qualifier. (Use -nullderef to inhibit warning)
   gzappend.c:405:11: Storage out may become null
gzappend.c:449:44: Function write expects arg 3 to be size_t gets int: len
gzappend.c:449:13: Assignment of ssize_t to int:
                      ret = write(gd, out + 8 - len, len)
gzappend.c:452:18: Test expression for while not boolean, type int: len
gzappend.c:453:9: Return value (type int) ignored: close(gd)
gzappend.c:457:10: Kept storage out passed as only param: free (out)
   gzappend.c:425:13: Storage out becomes kept
gzappend.c:458:10: Kept storage in passed as only param: free (in)
   gzappend.c:419:9: Storage in becomes kept
gzappend.c:459:17: Return value (type int) ignored: close(fd)
gzappend.c:460:2: Function returns with possibly null storage derivable from
                     parameter strm->next_out
   gzappend.c:425:30: Storage strm->next_out may become null
gzappend.c:460:2: Storage *strm reachable from parameter contains 1 undefined
                     field: next_out
gzappend.c:466:5: Function main defined more than once
  A function or variable is redefined. One of the declarations should use
  extern. (Use -redef to inhibit warning)
   enough.c:572:1: Previous definition of main
gzappend.c: (in function main)
gzappend.c:487:53: Operands of != have incompatible types (char, int):
                      argv[0][2] != 0
gzappend.c:489:9: Assignment of char to int: level = argv[0][1] - '0'
gzappend.c:494:26: Passed storage strm contains 14 undefined fields:
                      next_in, avail_in, total_in, next_out, ...
gzappend.c:498:16: Null storage passed as non-null param: gztack (NULL, ...)
gzappend.c:501:38: Function gztack expects arg 4 to be int gets boolean:
                      argv[1] == NULL
gzappend.c:503:14: Only storage strm.next_in (type Bytef *) derived from
    variable declared in this scope is not released (memory leak)
gzappend.c:503:14: Only storage strm.next_out (type Bytef *) derived from
    variable declared in this scope is not released (memory leak)
gzappend.c:503:14: Only storage strm.msg (type char *) derived from variable
                      declared in this scope is not released (memory leak)
gzappend.c:503:14: Only storage strm.state (type struct internal_state *)
    derived from variable declared in this scope is not released (memory leak)
gzappend.c:503:14: Only storage strm.zalloc (type alloc_func) derived from
    variable declared in this scope is not released (memory leak)
gzappend.c:503:14: Only storage strm.zfree (type free_func) derived from
    variable declared in this scope is not released (memory leak)
gzappend.c:503:14: Only storage strm.opaque (type voidpf) derived from variable
                      declared in this scope is not released (memory leak)
gzlog.c:242:22: Datatype uint defined more than once
   /usr/include/x86_64-linux-gnu/sys/types.h:150:22:
   Previous definition of uint
gzlog.c:243:23: Datatype ulong defined more than once
   /usr/include/x86_64-linux-gnu/sys/types.h:148:27:
   Previous definition of ulong
gzlog.c:307:5: Initial value of log_gzhead[0] is type int, expects unsigned
                  char: 0x1f
gzlog.c:307:11: Initial value of log_gzhead[1] is type int, expects unsigned
                   char: 0x8b
gzlog.c:308:5: Initial value of log_gzhead[2] is type int, expects unsigned
                  char: 8
gzlog.c:309:5: Initial value of log_gzhead[3] is type int, expects unsigned
                  char: 4
gzlog.c:314:3: Additional initialization errors for log_gzhead not reported
gzlog.c:320:5: Initial value of log_gzext[0] is type int, expects unsigned
                  char: 52
gzlog.c:320:9: Initial value of log_gzext[1] is type int, expects unsigned
                  char: 0
gzlog.c:320:12: Initial value of log_gzext[2] is type int, expects unsigned
                   char: 0
gzlog.c:320:15: Initial value of log_gzext[3] is type int, expects unsigned
                   char: 0
gzlog.c:326:3: Additional initialization errors for log_gzext not reported
gzlog.c:332:5: Initial value of log_gzbody[0] is type int, expects unsigned
                  char: 1
gzlog.c:332:8: Initial value of log_gzbody[1] is type int, expects unsigned
                  char: 0
gzlog.c:332:11: Initial value of log_gzbody[2] is type int, expects unsigned
                   char: 0
gzlog.c:332:14: Initial value of log_gzbody[3] is type int, expects unsigned
                   char: 0xff
gzlog.c:335:3: Additional initialization errors for log_gzbody not reported
gzlog.c: (in function log_lock)
gzlog.c:358:13: Return value (type int) ignored: unlink(log->path)
gzlog.c:361:9: Return value (type unsigned int) ignored: sleep(2)
gzlog.c:363:5: Return value (type int) ignored: close(fd)
gzlog.c:365:9: Assignment of __time_t to time_t: log->lock = st.st_mtim.tv_sec
gzlog.c: (in function log_touch)
gzlog.c:377:5: Unrecognized identifier: utimes
  Identifier used in code has not been declared. (Use -unrecog to inhibit
  warning)
gzlog.c:379:9: Assignment of __time_t to time_t: log->lock = st.st_mtim.tv_sec
gzlog.c: (in function log_check)
gzlog.c:389:33: Operands of != have incompatible types (__time_t, time_t):
                   st.st_mtim.tv_sec != log->lock
gzlog.c:389:9: Left operand of || is non-boolean (int):
                  stat(log->path, &st) || st.st_mtim.tv_sec != log->lock
gzlog.c: (in function log_unlock)
gzlog.c:398:9: Test expression for if not boolean, type int: log_check(log)
gzlog.c:401:5: Return value (type int) ignored: unlink(log->path)
gzlog.c: (in function log_head)
gzlog.c:416:9: Operands of != have incompatible types (ssize_t, arbitrary
    unsigned integral type): read(log->fd, buf, sizeof((log_gzhead)) +
    sizeof((log_gzext))) != sizeof((log_gzhead)) + sizeof((log_gzext))
gzlog.c:417:16: Passed storage buf not completely defined (*buf is undefined):
                   memcmp (buf, ...)
gzlog.c:417:9: Right operand of || is non-boolean (int):
    lseek(log->fd, 0, SEEK_SET) < 0 || read(log->fd, buf, sizeof((log_gzhead))
    + sizeof((log_gzext))) != sizeof((log_gzhead)) + sizeof((log_gzext)) ||
    memcmp(buf, log_gzhead, sizeof((log_gzhead)))
gzlog.c:420:52: Array element buf[1] used before definition
gzlog.c:420:21: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)))[0] + ((uint)((buf + sizeof((log_gzhead)))[1])
    << 8)
gzlog.c:420:21: Array element buf[0] used before definition
gzlog.c:420:137: Array element buf[1] used before definition
gzlog.c:420:104: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 2)[0] + ((uint)((buf + sizeof((log_gzhead)) +
    2)[1]) << 8)
gzlog.c:420:104: Array element buf[0] used before definition
gzlog.c:420:231: Array element buf[1] used before definition
gzlog.c:420:198: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 4)[0] + ((uint)((buf + sizeof((log_gzhead)) +
    4)[1]) << 8)
gzlog.c:420:198: Array element buf[0] used before definition
gzlog.c:420:321: Array element buf[1] used before definition
gzlog.c:420:285: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 4 + 2)[0] + ((uint)((buf +
    sizeof((log_gzhead)) + 4 + 2)[1]) << 8)
gzlog.c:420:285: Array element buf[0] used before definition
gzlog.c:420:189: Left operand of << may be negative (off_t):
    (off_t)(((buf + sizeof((log_gzhead)) + 4)[0] + ((uint)((buf +
    sizeof((log_gzhead)) + 4)[1]) << 8)) + ((ulong)((buf + sizeof((log_gzhead))
    + 4 + 2)[0] + ((uint)((buf + sizeof((log_gzhead)) + 4 + 2)[1]) << 8)) <<
    16)) << 32
gzlog.c:421:55: Array element buf[1] used before definition
gzlog.c:421:20: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 8)[0] + ((uint)((buf + sizeof((log_gzhead)) +
    8)[1]) << 8)
gzlog.c:421:20: Array element buf[0] used before definition
gzlog.c:421:149: Array element buf[1] used before definition
gzlog.c:421:111: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 8 + 2)[0] + ((uint)((buf +
    sizeof((log_gzhead)) + 8 + 2)[1]) << 8)
gzlog.c:421:111: Array element buf[0] used before definition
gzlog.c:421:253: Array element buf[1] used before definition
gzlog.c:421:215: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 8 + 4)[0] + ((uint)((buf +
    sizeof((log_gzhead)) + 8 + 4)[1]) << 8)
gzlog.c:421:215: Array element buf[0] used before definition
gzlog.c:421:353: Array element buf[1] used before definition
gzlog.c:421:312: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 8 + 4 + 2)[0] + ((uint)((buf +
    sizeof((log_gzhead)) + 8 + 4 + 2)[1]) << 8)
gzlog.c:421:312: Array element buf[0] used before definition
gzlog.c:421:206: Left operand of << may be negative (off_t):
    (off_t)(((buf + sizeof((log_gzhead)) + 8 + 4)[0] + ((uint)((buf +
    sizeof((log_gzhead)) + 8 + 4)[1]) << 8)) + ((ulong)((buf +
    sizeof((log_gzhead)) + 8 + 4 + 2)[0] + ((uint)((buf + sizeof((log_gzhead))
    + 8 + 4 + 2)[1]) << 8)) << 16)) << 32
gzlog.c:422:55: Array element buf[1] used before definition
gzlog.c:422:19: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 16)[0] + ((uint)((buf + sizeof((log_gzhead))
    + 16)[1]) << 8)
gzlog.c:422:19: Array element buf[0] used before definition
gzlog.c:422:151: Array element buf[1] used before definition
gzlog.c:422:112: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 16 + 2)[0] + ((uint)((buf +
    sizeof((log_gzhead)) + 16 + 2)[1]) << 8)
gzlog.c:422:112: Array element buf[0] used before definition
gzlog.c:423:55: Array element buf[1] used before definition
gzlog.c:423:19: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 20)[0] + ((uint)((buf + sizeof((log_gzhead))
    + 20)[1]) << 8)
gzlog.c:423:19: Array element buf[0] used before definition
gzlog.c:423:151: Array element buf[1] used before definition
gzlog.c:423:112: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 20 + 2)[0] + ((uint)((buf +
    sizeof((log_gzhead)) + 20 + 2)[1]) << 8)
gzlog.c:423:112: Array element buf[0] used before definition
gzlog.c:424:55: Array element buf[1] used before definition
gzlog.c:424:19: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 24)[0] + ((uint)((buf + sizeof((log_gzhead))
    + 24)[1]) << 8)
gzlog.c:424:19: Array element buf[0] used before definition
gzlog.c:424:151: Array element buf[1] used before definition
gzlog.c:424:112: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 24 + 2)[0] + ((uint)((buf +
    sizeof((log_gzhead)) + 24 + 2)[1]) << 8)
gzlog.c:424:112: Array element buf[0] used before definition
gzlog.c:425:55: Array element buf[1] used before definition
gzlog.c:425:19: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 28)[0] + ((uint)((buf + sizeof((log_gzhead))
    + 28)[1]) << 8)
gzlog.c:425:19: Array element buf[0] used before definition
gzlog.c:425:151: Array element buf[1] used before definition
gzlog.c:425:112: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 28 + 2)[0] + ((uint)((buf +
    sizeof((log_gzhead)) + 28 + 2)[1]) << 8)
gzlog.c:425:112: Array element buf[0] used before definition
gzlog.c:426:56: Array element buf[1] used before definition
gzlog.c:426:20: Incompatible types for + (unsigned char, uint):
    (buf + sizeof((log_gzhead)) + 32)[0] + ((uint)((buf + sizeof((log_gzhead))
    + 32)[1]) << 8)
gzlog.c:426:20: Array element buf[0] used before definition
gzlog.c:427:22: Value buf[] used before definition
gzlog.c:427:17: Incompatible types for + (int, unsigned char):
                   3 + (buf[sizeof((log_gzhead)) + 34] & 7)
gzlog.c:428:5: Assignment of unsigned char to int:
                  op = (buf[sizeof((log_gzhead)) + 34] >> 3) & 3
gzlog.c: (in function log_mark)
gzlog.c:442:17: Assignment of off_t to unsigned char: (ext)[0] = log->first
gzlog.c:442:47: Left operand of >> may be negative (off_t): (log->first) >> 8
gzlog.c:442:38: Assignment of off_t to unsigned char:
                   (ext)[1] = (log->first) >> 8
gzlog.c:442:91: Left operand of >> may be negative (off_t): log->first >> 16
gzlog.c:442:79: Assignment of off_t to unsigned char:
                   (ext + 2)[0] = log->first >> 16
gzlog.c:442:119: Left operand of >> may be negative (off_t): log->first >> 16
gzlog.c:442:117: Left operand of >> may be negative (off_t):
                    (log->first >> 16) >> 8
gzlog.c:442:106: Assignment of off_t to unsigned char:
                    (ext + 2)[1] = (log->first >> 16) >> 8
gzlog.c:442:180: Left operand of >> may be negative (off_t): log->first >> 32
gzlog.c:442:168: Assignment of off_t to unsigned char:
                    (ext + 4)[0] = log->first >> 32
gzlog.c:442:208: Left operand of >> may be negative (off_t): log->first >> 32
gzlog.c:442:206: Left operand of >> may be negative (off_t):
                    (log->first >> 32) >> 8
gzlog.c:442:195: Assignment of off_t to unsigned char:
                    (ext + 4)[1] = (log->first >> 32) >> 8
gzlog.c:442:257: Left operand of >> may be negative (off_t): log->first >> 32
gzlog.c:442:257: Left operand of >> may be negative (off_t):
                    log->first >> 32 >> 16
gzlog.c:442:242: Assignment of off_t to unsigned char:
                    (ext + 4 + 2)[0] = log->first >> 32 >> 16
gzlog.c:442:292: Left operand of >> may be negative (off_t): log->first >> 32
gzlog.c:442:292: Left operand of >> may be negative (off_t):
                    log->first >> 32 >> 16
gzlog.c:442:290: Left operand of >> may be negative (off_t):
                    (log->first >> 32 >> 16) >> 8
gzlog.c:442:276: Assignment of off_t to unsigned char:
                    (ext + 4 + 2)[1] = (log->first >> 32 >> 16) >> 8
gzlog.c:443:17: Assignment of off_t to unsigned char: (ext + 8)[0] = log->last
gzlog.c:443:54: Left operand of >> may be negative (off_t): (log->last) >> 8
gzlog.c:443:41: Assignment of off_t to unsigned char:
                   (ext + 8)[1] = (log->last) >> 8
gzlog.c:443:102: Left operand of >> may be negative (off_t): log->last >> 16
gzlog.c:443:85: Assignment of off_t to unsigned char:
                   (ext + 8 + 2)[0] = log->last >> 16
gzlog.c:443:134: Left operand of >> may be negative (off_t): log->last >> 16
gzlog.c:443:132: Left operand of >> may be negative (off_t):
                    (log->last >> 16) >> 8
gzlog.c:443:116: Assignment of off_t to unsigned char:
                    (ext + 8 + 2)[1] = (log->last >> 16) >> 8
gzlog.c:443:199: Left operand of >> may be negative (off_t): log->last >> 32
gzlog.c:443:182: Assignment of off_t to unsigned char:
                    (ext + 8 + 4)[0] = log->last >> 32
gzlog.c:443:231: Left operand of >> may be negative (off_t): log->last >> 32
gzlog.c:443:229: Left operand of >> may be negative (off_t):
                    (log->last >> 32) >> 8
gzlog.c:443:213: Assignment of off_t to unsigned char:
                    (ext + 8 + 4)[1] = (log->last >> 32) >> 8
gzlog.c:443:284: Left operand of >> may be negative (off_t): log->last >> 32
gzlog.c:443:284: Left operand of >> may be negative (off_t):
                    log->last >> 32 >> 16
gzlog.c:443:264: Assignment of off_t to unsigned char:
                    (ext + 8 + 4 + 2)[0] = log->last >> 32 >> 16
gzlog.c:443:323: Left operand of >> may be negative (off_t): log->last >> 32
gzlog.c:443:323: Left operand of >> may be negative (off_t):
                    log->last >> 32 >> 16
gzlog.c:443:321: Left operand of >> may be negative (off_t):
                    (log->last >> 32 >> 16) >> 8
gzlog.c:443:302: Assignment of off_t to unsigned char:
                    (ext + 8 + 4 + 2)[1] = (log->last >> 32 >> 16) >> 8
gzlog.c:444:13: Assignment of ulong to unsigned char: (ext + 16)[0] = log->ccrc
gzlog.c:444:38: Assignment of ulong to unsigned char:
                   (ext + 16)[1] = (log->ccrc) >> 8
gzlog.c:444:83: Assignment of ulong to unsigned char:
                   (ext + 16 + 2)[0] = log->ccrc >> 16
gzlog.c:444:115: Assignment of ulong to unsigned char:
                    (ext + 16 + 2)[1] = (log->ccrc >> 16) >> 8
gzlog.c:445:13: Assignment of ulong to unsigned char: (ext + 20)[0] = log->clen
gzlog.c:445:38: Assignment of ulong to unsigned char:
                   (ext + 20)[1] = (log->clen) >> 8
gzlog.c:445:83: Assignment of ulong to unsigned char:
                   (ext + 20 + 2)[0] = log->clen >> 16
gzlog.c:445:115: Assignment of ulong to unsigned char:
                    (ext + 20 + 2)[1] = (log->clen >> 16) >> 8
gzlog.c:446:13: Assignment of ulong to unsigned char: (ext + 24)[0] = log->tcrc
gzlog.c:446:38: Assignment of ulong to unsigned char:
                   (ext + 24)[1] = (log->tcrc) >> 8
gzlog.c:446:83: Assignment of ulong to unsigned char:
                   (ext + 24 + 2)[0] = log->tcrc >> 16
gzlog.c:446:115: Assignment of ulong to unsigned char:
                    (ext + 24 + 2)[1] = (log->tcrc >> 16) >> 8
gzlog.c:447:13: Assignment of ulong to unsigned char: (ext + 28)[0] = log->tlen
gzlog.c:447:38: Assignment of ulong to unsigned char:
                   (ext + 28)[1] = (log->tlen) >> 8
gzlog.c:447:83: Assignment of ulong to unsigned char:
                   (ext + 28 + 2)[0] = log->tlen >> 16
gzlog.c:447:115: Assignment of ulong to unsigned char:
                    (ext + 28 + 2)[1] = (log->tlen >> 16) >> 8
gzlog.c:448:9: Assignment of uint to unsigned char: (ext + 32)[0] = log->stored
gzlog.c:448:36: Assignment of uint to unsigned char:
                   (ext + 32)[1] = (log->stored) >> 8
gzlog.c:449:32: Left operand of << may be negative (int): op << 3
gzlog.c:449:5: Assignment of int to unsigned char:
                  ext[34] = log->back - 3 + (op << 3)
gzlog.c:450:5: Return value (type int) ignored: fsync(log->fd)
gzlog.c:451:32: Function lseek expects arg 2 to be __off_t gets size_t:
                   sizeof((log_gzhead))
gzlog.c:452:11: Operands of != have incompatible types (ssize_t, size_t):
    write(log->fd, ext, sizeof((log_gzext))) != sizeof((log_gzext))
gzlog.c:453:5: Return value (type int) ignored: fsync(log->fd)
gzlog.c: (in function log_last)
gzlog.c:470:20: Right operand of >> may be negative (int):
                   0x80 >> ((back - 1) & 7)
gzlog.c:475:5: Assignment of int to unsigned char: buf[0] = 0
gzlog.c:476:38: Function lseek expects arg 2 to be __off_t gets arbitrary
                   integral type: log->last - len
gzlog.c:484:5: Assignment of int to unsigned char: buf[1] = 0
gzlog.c:485:43: Test expression for conditional not boolean, type int: last
gzlog.c:485:20: Incompatible types for + (unsigned char, int):
                   (*buf & (mask - 1)) + (last ? mask : 0)
gzlog.c:489:9: Assignment of uint to unsigned char: (buf + 2)[0] = log->stored
gzlog.c:489:35: Assignment of uint to unsigned char:
                   (buf + 2)[1] = (log->stored) >> 8
gzlog.c:490:9: Assignment of uint to unsigned char:
                  (buf + 4)[0] = log->stored ^ 0xffff
gzlog.c:490:44: Assignment of uint to unsigned char:
                   (buf + 4)[1] = (log->stored ^ 0xffff) >> 8
gzlog.c:491:27: Function lseek expects arg 2 to be __off_t gets arbitrary
                   integral type: log->last - len
gzlog.c:492:42: Function write expects arg 3 to be size_t gets int: len + 4
gzlog.c:492:12: Operands of != have incompatible types (ssize_t, int):
                   write(log->fd, buf + 2 - len, len + 4) != len + 4
gzlog.c:493:27: Function lseek expects arg 2 to be __off_t gets uint:
                   log->stored
gzlog.c: (in function log_append)
gzlog.c:510:9: Test expression for if not boolean, type int: log_last(log, 1)
gzlog.c:515:12: Test expression for while not boolean, type size_t: len
gzlog.c:517:9: Assignment of int to uint: put = (16 << 10) - log->stored
gzlog.c:518:13: Operands of > have incompatible types (uint, size_t): put > len
gzlog.c:520:13: Test expression for if not boolean, type uint: put
gzlog.c:521:38: Function write expects arg 3 to be size_t gets uint: put
gzlog.c:521:17: Operands of != have incompatible types (ssize_t, uint):
                   write(log->fd, data, put) != put
gzlog.c:532:13: Test expression for if not boolean, type size_t: len
gzlog.c:534:17: Test expression for if not boolean, type int: log_last(log, 0)
gzlog.c:543:13: Test expression for if not boolean, type int: log_last(log, 1)
gzlog.c:550:13: Assignment of ulong to unsigned char: (buf)[0] = log->tcrc
gzlog.c:550:33: Assignment of ulong to unsigned char:
                   (buf)[1] = (log->tcrc) >> 8
gzlog.c:550:73: Assignment of ulong to unsigned char:
                   (buf + 2)[0] = log->tcrc >> 16
gzlog.c:550:99: Assignment of ulong to unsigned char:
                   (buf + 2)[1] = (log->tcrc >> 16) >> 8
gzlog.c:551:13: Assignment of ulong to unsigned char: (buf + 4)[0] = log->tlen
gzlog.c:551:37: Assignment of ulong to unsigned char:
                   (buf + 4)[1] = (log->tlen) >> 8
gzlog.c:551:81: Assignment of ulong to unsigned char:
                   (buf + 4 + 2)[0] = log->tlen >> 16
gzlog.c:551:112: Assignment of ulong to unsigned char:
                    (buf + 4 + 2)[1] = (log->tlen >> 16) >> 8
gzlog.c:553:10: Assignment of __off_t to off_t:
                   end = lseek(log->fd, 0, SEEK_CUR)
gzlog.c:553:71: Function ftruncate expects arg 2 to be __off_t gets off_t: end
gzlog.c:553:71: Variable end used before definition
gzlog.c:553:52: Right operand of || is non-boolean (int):
    write(log->fd, buf, 8) != 8 || (end = lseek(log->fd, 0, SEEK_CUR)) < 0 ||
    ftruncate(log->fd, end)
gzlog.c:557:9: Test expression for if not boolean, type int: log_mark(log, 0)
gzlog.c:560:5: Return value (type int) ignored: unlink(log->path)
gzlog.c: (in function log_replace)
gzlog.c:578:5: Return value (type int) ignored: unlink(log->path)
gzlog.c:590:9: Left operand of && is non-boolean (int): ret && errno != ENOENT
gzlog.c: (in function log_compress)
gzlog.c:618:9: Test expression for if not boolean, type size_t: len
gzlog.c:620:9: Assignment of int to alloc_func: strm.zalloc = 0
gzlog.c:621:9: Assignment of int to free_func: strm.zfree = 0
gzlog.c:623:27: Null storage strm.zalloc derivable from parameter deflateInit2_
                   ((&strm), ...)
   gzlog.c:620:23: Storage strm.zalloc becomes null
gzlog.c:623:27: Null storage strm.zfree derivable from parameter deflateInit2_
                   ((&strm), ...)
   gzlog.c:621:22: Storage strm.zfree becomes null
gzlog.c:623:27: Null storage strm.opaque derivable from parameter deflateInit2_
                   ((&strm), ...)
   gzlog.c:622:23: Storage strm.opaque becomes null
gzlog.c:623:27: Passed storage strm contains 11 undefined fields:
                   next_in, avail_in, total_in, next_out, ...
gzlog.c:625:23: Only storage strm.next_in (type Bytef *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:625:23: Only storage strm.next_out (type Bytef *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:625:23: Only storage strm.msg (type char *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:625:23: Only storage strm.state (type struct internal_state *) derived
    from variable declared in this scope is not released (memory leak)
gzlog.c:625:23: Only storage strm.zalloc (type alloc_func) derived from
    variable declared in this scope is not released (memory leak)
gzlog.c:625:23: Only storage strm.zfree (type free_func) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:625:23: Only storage strm.opaque (type voidpf) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:629:40: Null storage passed as non-null param: open (..., 0)
gzlog.c:631:34: Function read expects arg 3 to be size_t gets unsigned int:
                   32768U
gzlog.c:632:13: Return value (type int) ignored: close(fd)
gzlog.c:634:17: Return value (type int) ignored: deflateEnd(&strm)
gzlog.c:635:27: Only storage strm.next_in (type Bytef *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:635:27: Only storage strm.next_out (type Bytef *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:635:27: Only storage strm.msg (type char *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:635:27: Only storage strm.state (type struct internal_state *) derived
    from variable declared in this scope is not released (memory leak)
gzlog.c:635:27: Only storage strm.zalloc (type alloc_func) derived from
    variable declared in this scope is not released (memory leak)
gzlog.c:635:27: Only storage strm.zfree (type free_func) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:635:27: Only storage strm.opaque (type voidpf) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:637:17: Test expression for if not boolean, type ssize_t: dict
gzlog.c:638:17: Return value (type int) ignored: deflateSetDictio...
gzlog.c:644:28: Function lseek expects arg 2 to be __off_t gets arbitrary
                   integral type: log->first - (log->back > 8 ? 2 : 1)
gzlog.c:647:13: Return value (type int) ignored: deflateEnd(&strm)
gzlog.c:648:23: Only storage strm.next_in (type Bytef *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:648:23: Only storage strm.next_out (type Bytef *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:648:23: Only storage strm.msg (type char *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:648:23: Only storage strm.state (type struct internal_state *) derived
    from variable declared in this scope is not released (memory leak)
gzlog.c:648:23: Only storage strm.zalloc (type alloc_func) derived from
    variable declared in this scope is not released (memory leak)
gzlog.c:648:23: Only storage strm.zfree (type free_func) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:648:23: Only storage strm.opaque (type voidpf) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:650:50: Function deflatePrime expects arg 3 to be int gets unsigned
                   char: *buf
gzlog.c:650:50: Value *buf used before definition
gzlog.c:650:9: Return value (type int) ignored: deflatePrime(&st...
gzlog.c:653:9: Implicitly only storage strm.next_in (type Bytef *) not released
                  before assignment: strm.next_in = data
gzlog.c:654:16: Left operand of >> may be negative (int): ((uint)0 - 1) >> 1
gzlog.c:654:9: Assignment of int to uint: max = (((uint)0 - 1) >> 1) + 1
gzlog.c:656:29: Operands of > have incompatible types (size_t, uint): len > max
gzlog.c:660:17: Implicitly only storage strm.next_out (type Bytef *) not
                   released before assignment: strm.next_out = buf
gzlog.c:661:32: Test expression for conditional not boolean, type size_t: len
gzlog.c:661:25: Storage strm.next_out reachable from passed parameter is stack
                   (should be implicitly only): &strm
   gzlog.c:660:17: Storage strm.next_out becomes stack-allocated storage
gzlog.c:661:17: Return value (type int) ignored: deflate(&strm, l...
gzlog.c:663:48: Function write expects arg 3 to be size_t gets uint: got
gzlog.c:663:28: Operands of != have incompatible types (ssize_t, uint):
                   write(log->fd, buf, got) != got
gzlog.c:663:21: Left operand of && is non-boolean (uint):
                   got && write(log->fd, buf, got) != got
gzlog.c:664:32: Storage strm.next_out reachable from passed parameter is stack
                   (should be implicitly only): &strm
   gzlog.c:660:17: Storage strm.next_out becomes stack-allocated storage
gzlog.c:664:21: Return value (type int) ignored: deflateEnd(&strm)
gzlog.c:665:31: Only storage strm.next_in (type Bytef *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:665:31: Only storage strm.msg (type char *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:665:31: Only storage strm.state (type struct internal_state *) derived
    from variable declared in this scope is not released (memory leak)
gzlog.c:665:31: Only storage strm.zalloc (type alloc_func) derived from
    variable declared in this scope is not released (memory leak)
gzlog.c:665:31: Only storage strm.zfree (type free_func) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:665:31: Only storage strm.opaque (type voidpf) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:669:18: Test expression for while not boolean, type size_t: len
gzlog.c:670:20: Storage strm.next_out reachable from passed parameter is stack
                   (should be implicitly only): &strm
   gzlog.c:660:17: Storage strm.next_out becomes stack-allocated storage
gzlog.c:670:9: Return value (type int) ignored: deflateEnd(&strm)
gzlog.c:677:14: Assignment of __off_t to off_t:
                   log->first = lseek(log->fd, -1, SEEK_CUR)
gzlog.c:679:23: Only storage strm.next_in (type Bytef *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:679:23: Only storage strm.msg (type char *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:679:23: Only storage strm.state (type struct internal_state *) derived
    from variable declared in this scope is not released (memory leak)
gzlog.c:679:23: Only storage strm.zalloc (type alloc_func) derived from
    variable declared in this scope is not released (memory leak)
gzlog.c:679:23: Only storage strm.zfree (type free_func) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:679:23: Only storage strm.opaque (type voidpf) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:681:13: Test expression for if not boolean, type unsigned char: *buf
  Test expression type is not boolean. (Use -predboolothers to inhibit warning)
gzlog.c:683:40: Right operand of << may be negative (int):
                   (uint)1 << (8 - log->back++)
gzlog.c:683:20: Operands of == have incompatible types (unsigned char, int):
                   (*buf & ((uint)1 << (8 - log->back++))) == 0
gzlog.c:697:5: Variable data is kept in true branch, but not kept in false
                  branch.
   gzlog.c:697:5: in true branch:
   gzlog.c:653:9: Storage data becomes kept
gzlog.c:702:13: Assignment of ulong to unsigned char: (buf)[0] = log->tcrc
gzlog.c:702:33: Assignment of ulong to unsigned char:
                   (buf)[1] = (log->tcrc) >> 8
gzlog.c:702:73: Assignment of ulong to unsigned char:
                   (buf + 2)[0] = log->tcrc >> 16
gzlog.c:702:99: Assignment of ulong to unsigned char:
                   (buf + 2)[1] = (log->tcrc >> 16) >> 8
gzlog.c:703:13: Assignment of ulong to unsigned char: (buf + 4)[0] = log->tlen
gzlog.c:703:37: Assignment of ulong to unsigned char:
                   (buf + 4)[1] = (log->tlen) >> 8
gzlog.c:703:81: Assignment of ulong to unsigned char:
                   (buf + 4 + 2)[0] = log->tlen >> 16
gzlog.c:703:112: Assignment of ulong to unsigned char:
                    (buf + 4 + 2)[1] = (log->tlen >> 16) >> 8
gzlog.c:704:9: Left operand of || is non-boolean (int):
                  log_last(log, 1) || write(log->fd, buf, 8) != 8
gzlog.c:705:10: Assignment of __off_t to off_t:
                   end = lseek(log->fd, 0, SEEK_CUR)
gzlog.c:705:71: Function ftruncate expects arg 2 to be __off_t gets off_t: end
gzlog.c:705:71: Variable end used before definition
gzlog.c:705:52: Right operand of || is non-boolean (int):
    log_last(log, 1) || write(log->fd, buf, 8) != 8 || (end = lseek(log->fd, 0,
    SEEK_CUR)) < 0 || ftruncate(log->fd, end)
gzlog.c:706:19: Only storage strm.next_in (type Bytef *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:706:19: Only storage strm.next_out (type Bytef *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:706:19: Only storage strm.msg (type char *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:706:19: Only storage strm.state (type struct internal_state *) derived
    from variable declared in this scope is not released (memory leak)
gzlog.c:706:19: Only storage strm.zalloc (type alloc_func) derived from
    variable declared in this scope is not released (memory leak)
gzlog.c:706:19: Only storage strm.zfree (type free_func) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:706:19: Only storage strm.opaque (type voidpf) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:710:9: Test expression for if not boolean, type int: log_mark(log, 3)
gzlog.c:711:19: Only storage strm.next_in (type Bytef *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:711:19: Only storage strm.next_out (type Bytef *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:711:19: Only storage strm.msg (type char *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:711:19: Only storage strm.state (type struct internal_state *) derived
    from variable declared in this scope is not released (memory leak)
gzlog.c:711:19: Only storage strm.zalloc (type alloc_func) derived from
    variable declared in this scope is not released (memory leak)
gzlog.c:711:19: Only storage strm.zfree (type free_func) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:711:19: Only storage strm.opaque (type voidpf) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:714:29: Only storage strm.next_in (type Bytef *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:714:29: Only storage strm.next_out (type Bytef *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:714:29: Only storage strm.msg (type char *) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:714:29: Only storage strm.state (type struct internal_state *) derived
    from variable declared in this scope is not released (memory leak)
gzlog.c:714:29: Only storage strm.zalloc (type alloc_func) derived from
    variable declared in this scope is not released (memory leak)
gzlog.c:714:29: Only storage strm.zfree (type free_func) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c:714:29: Only storage strm.opaque (type voidpf) derived from variable
                   declared in this scope is not released (memory leak)
gzlog.c: (in function log_log)
gzlog.c:730:5: Return value (type int) ignored: fclose(rec)
gzlog.c: (in function log_recover)
gzlog.c:751:42: Right operand of && is non-boolean (__off_t):
                   stat(log->path, &st) == 0 && st.st_size
gzlog.c:753:17: Operands of != have incompatible types (off_t, __off_t):
                   (off_t)len != st.st_size
gzlog.c:754:36: Function malloc expects arg 1 to be size_t gets __off_t:
                   st.st_size
gzlog.c:758:49: Null storage passed as non-null param: open (..., 0)
gzlog.c:760:27: Fresh storage data not released before return
  A memory leak has been detected. Storage allocated locally is not released
  before the last reference to it is lost. (Use -mustfreefresh to inhibit
  warning)
   gzlog.c:754:22: Fresh storage data created
gzlog.c:762:13: Assignment of boolean to int:
                   ret = (size_t)read(fd, data, len) != len
gzlog.c:763:13: Return value (type int) ignored: close(fd)
gzlog.c:764:17: Test expression for if not boolean, type int: ret
gzlog.c:766:27: Fresh storage data not released before return
   gzlog.c:754:22: Fresh storage data created
gzlog.c:777:31: Possibly null storage data passed as non-null param:
                   log_append (..., data, ...)
   gzlog.c:741:27: Storage data may become null
gzlog.c:780:33: Possibly null storage data passed as non-null param:
                   log_compress (..., data, ...)
   gzlog.c:741:27: Storage data may become null
gzlog.c:787:22: Test expression for conditional not boolean, type int: ret
gzlog.c: (in function log_close)
gzlog.c:799:9: Return value (type int) ignored: close(log->fd)
gzlog.c: (in function log_open)
gzlog.c:820:9: Return value (type int) ignored: close(log->fd)
gzlog.c:837:13: Operands of != have incompatible types (ssize_t, size_t):
    write(log->fd, log_gzhead, sizeof((log_gzhead))) != sizeof((log_gzhead))
gzlog.c:838:13: Operands of != have incompatible types (ssize_t, size_t):
    write(log->fd, log_gzext, sizeof((log_gzext))) != sizeof((log_gzext))
gzlog.c:839:13: Operands of != have incompatible types (ssize_t, size_t):
    write(log->fd, log_gzbody, sizeof((log_gzbody))) != sizeof((log_gzbody))
gzlog.c:844:9: Return value (type int) ignored: unlink(log->path)
gzlog.c:854:20: Right operand of && is non-boolean (int):
                   op != 0 && log_recover(log, op)
gzlog.c: (in function gzlog_open)
gzlog.c:871:25: Operands of == have incompatible types (char, int): *path == 0
gzlog.c:872:16: Null storage returned as non-null: NULL
  Function returns a possibly null pointer, but is not declared using
  /*@null@*/ annotation of result.  If function may return NULL, add /*@null@*/
  annotation to the return value declaration. (Use -nullret to inhibit warning)
gzlog.c:877:16: Null storage returned as non-null: NULL
gzlog.c:886:16: Null storage returned as non-null: NULL
gzlog.c:889:5: Dependent storage log->path assigned to implicitly only:
                  log->end = log->path + n
   gzlog.c:889:16: Storage log->path becomes dependent
gzlog.c:893:18: Storage log->path reachable from passed parameter is kept
                   (should be implicitly only): log
   gzlog.c:889:5: Storage log->path becomes kept
gzlog.c:893:18: Passed storage *log contains 9 undefined fields:
                   first, back, stored, last, ...
gzlog.c:893:9: Test expression for if not boolean, type int: log_open(log)
gzlog.c:896:16: Null storage returned as non-null: NULL
gzlog.c:900:12: Return value type struct log * does not match declared type
                   gzlog *: log
gzlog.c:900:16: Fresh storage log not released before return
   gzlog.c:875:5: Fresh storage log created
gzlog.c: (in function gzlog_compress)
gzlog.c:914:23: Variable log initialized to type gzlog *, expects struct log *:
                   logd
gzlog.c:917:24: Right operand of || is non-boolean (int):
                   log == NULL || strcmp(log->id, "\106\035\172")
gzlog.c:923:9: Operands of && are non-boolean (int):
                  log_check(log) && log_open(log)
gzlog.c:935:28: Function lseek expects arg 2 to be __off_t gets arbitrary
                   integral type: log->first - 1
gzlog.c:941:22: Incompatible types for + (unsigned char, uint):
                   (buf + 1)[0] + ((uint)((buf + 1)[1]) << 8)
gzlog.c:943:52: Function read expects arg 3 to be size_t gets uint: block
gzlog.c:943:17: Operands of != have incompatible types (ssize_t, uint):
                   read(log->fd, (char *)data + next, block) != block
gzlog.c:947:13: Operands of != have incompatible types (__off_t, arbitrary
    integral type): lseek(log->fd, 0, SEEK_CUR) != log->last + 4 + log->stored
gzlog.c:956:33: Passed storage data not completely defined (*data is
                   undefined): write (..., data, ...)
   gzlog.c:929:10: Storage *data allocated
gzlog.c:956:9: Assignment of boolean to int:
                  ret = (size_t)write(fd, data, len) != len
gzlog.c:957:13: Test expression for if not boolean, type int: ret | close(fd)
gzlog.c:966:16: Operands of > have incompatible types (unsigned int, size_t):
                   32768U > len
gzlog.c:966:31: Conditional clauses are not of same type:
                   len (size_t), 32768U (unsigned int)
gzlog.c:967:9: Assignment of boolean to int:
    ret = (size_t)write(fd, (char *)data + len - next, next) != next
gzlog.c:968:13: Test expression for if not boolean, type int: ret | close(fd)
gzlog.c:975:13: Test expression for if not boolean, type int: log_mark(log, 2)
gzlog.c:986:10: Dead storage data passed as out parameter to free: data
  Memory is used after it has been released (either by passing as an only param
  or assigning to an only global). (Use -usereleased to inhibit warning)
   gzlog.c:981:14: Storage data released
gzlog.c: (in function gzlog_write)
gzlog.c:998:23: Variable log initialized to type gzlog *, expects struct log *:
                   logd
gzlog.c:1001:24: Right operand of || is non-boolean (int):
                    log == NULL || strcmp(log->id, "\106\035\172")
gzlog.c:1003:25: Comparison of unsigned value involving zero: len <= 0
  An unsigned value is used in a comparison with zero in a way that is either a
  bug or confusing. (Use -unsignedcompare to inhibit warning)
gzlog.c:1009:9: Operands of && are non-boolean (int):
                   log_check(log) && log_open(log)
gzlog.c:1017:5: Assignment of boolean to int:
                   ret = (size_t)write(fd, data, len) != len
gzlog.c:1018:9: Test expression for if not boolean, type int: ret | close(fd)
gzlog.c:1023:9: Test expression for if not boolean, type int: log_mark(log, 1)
gzlog.c:1028:9: Test expression for if not boolean, type int:
                   log_append(log, data, len)
gzlog.c:1032:10: Left operand of >> may be negative (arbitrary integral type):
                    (log->last - log->first) >> 10
gzlog.c:1036:27: Function gzlog_compress expects arg 1 to be gzlog * gets
                    struct log *: log
gzlog.c: (in function gzlog_close)
gzlog.c:1044:23: Variable log initialized to type gzlog *, expects struct log
                    *: logd
gzlog.c:1047:24: Right operand of || is non-boolean (int):
                    log == NULL || strcmp(log->id, "\106\035\172")
gzlog.c:1057:10: Implicitly temp storage logd passed as only param (log aliases
                    logd): free (log)
  Temp storage (associated with a formal parameter) is transferred to a
  non-temporary reference. The storage may be released or new aliases created.
  (Use -temptrans to inhibit warning)
minigzip.c:350:6: Function main defined more than once
   enough.c:572:1: Previous definition of main
minigzip.c: (in function error)
minigzip.c:359:10: Argument to exit has implementation defined behavior: 1
minigzip.c: (in function gz_compress)
minigzip.c:382:13: Test expression for if not boolean, type int: ferror(in)
minigzip.c:384:18: Argument to exit has implementation defined behavior: 1
minigzip.c:388:73: Passed storage &err not completely defined:
                      gzerror (..., &err)
minigzip.c:388:60: New fresh storage (type char *) passed as unqualified (not
                      released): gzerror(out, &err)
minigzip.c:390:5: Return value (type int) ignored: fclose(in)
minigzip.c:391:34: Observer storage passed as unqualified param:
                      error ("failed gzclose")
  Observer storage is transferred to a non-observer reference. (Use
  -observertrans to inhibit warning)
   minigzip.c:391:34: Storage becomes observer
minigzip.c: (in function gz_uncompress)
minigzip.c:443:37: Function gzread expects arg 3 to be unsigned int gets
                      size_t: sizeof((buf))
minigzip.c:443:26: Passed storage buf not completely defined (*buf is
                      undefined): gzread (..., buf, ...)
minigzip.c:444:41: Passed storage &err not completely defined:
                      gzerror (..., &err)
minigzip.c:444:29: New fresh storage (type char *) passed as unqualified (not
                      released): gzerror(in, &err)
minigzip.c:447:33: Function fwrite expects arg 3 to be size_t gets unsigned
                      int: (unsigned int)len
minigzip.c:448:19: Observer storage passed as unqualified param:
                      error ("failed fwrite")
   minigzip.c:448:19: Storage becomes observer
minigzip.c:451:9: Test expression for if not boolean, type int: fclose(out)
minigzip.c:451:28: Observer storage passed as unqualified param:
                      error ("failed fclose")
   minigzip.c:451:28: Storage becomes observer
minigzip.c:453:33: Observer storage passed as unqualified param:
                      error ("failed gzclose")
   minigzip.c:453:33: Storage becomes observer
